# Описание реализации

## Реализованные компоненты

### 1. Заполнение матриц методом "Разделяй и властвуй"

Функция `fill_matrix_divide_conquer()` реализует рекурсивное заполнение матрицы:
- Разделяет матрицу на 4 подматрицы
- Рекурсивно заполняет каждую подматрицу
- Объединяет результаты с помощью `np.hstack()` и `np.vstack()`

**Сложность**: O(n²) по времени, O(n²) по памяти

### 2. Переупорядочивание матрицы

Функция `reorder_matrix_for_cache()` выполняет транспонирование матрицы для оптимизации доступа к данным:
- Транспонирует матрицу B → B^T
- Улучшает кэш-локальность при доступе по столбцам
- Используется во всех вариантах умножения

### 3. Параллельное умножение матриц

#### Последовательная версия
`multiply_matrices_sequential()` - классическое умножение с переупорядочиванием:
```python
for i in range(n):
    for k in range(m):
        for j in range(k):
            result[i, j] += A[i, k] * B_T[j, k]
```

#### Параллельная версия
`multiply_matrices_parallel()` использует `multiprocessing.Process`:
- Распределяет строки результирующей матрицы между процессами
- Каждый процесс обрабатывает свой диапазон строк
- Результаты собираются через `multiprocessing.Queue`

#### Варианты линеаризации циклов

1. **Вариант 1** (`multiply_matrices_linearized_v1`): Линеаризация (i, k, j)
   - Порядок: сначала i, затем k, затем j
   
2. **Вариант 2** (`multiply_matrices_linearized_v2`): Линеаризация (k, i, j)
   - Порядок: сначала k, затем i, затем j
   
3. **Вариант 3** (`multiply_matrices_linearized_v3`): Линеаризация (j, i, k)
   - Порядок: сначала j, затем i, затем k

### 4. Эксперименты

#### Эксперимент 1: Зависимость от количества потоков
- Тестирует производительность для разных количеств процессов (1, 2, 4, 8, ...)
- Размеры матриц: 10, 50, 100, 500, 1000, 2000, 5000, 10000
- Вычисляет ускорение относительно однопоточного варианта

#### Эксперимент 2: Зависимость от размерности
- Тестирует производительность для разных размеров матриц
- Сравнивает последовательную и параллельную версии
- Вычисляет ускорение

#### Эксперимент 3: Сравнение линеаризаций
- Сравнивает 3 варианта линеаризации циклов
- Определяет оптимальный вариант для каждого размера матрицы

#### Вывод формулы
Использует метод наименьших квадратов для аппроксимации зависимости:
```
T(n, p) = a * n^b / p^c
```

где:
- `n` - размерность матрицы
- `p` - количество потоков
- `a, b, c` - коэффициенты, найденные регрессией

## Технические детали

### Использование multiprocessing

В Windows необходимо использовать конструкцию `if __name__ == '__main__'` для корректной работы multiprocessing. Это учтено в `experiment.py`.

### Передача данных между процессами

Матрицы передаются между процессами в виде списков Python (через `tolist()`), так как numpy массивы не могут быть сериализованы напрямую через pickle в некоторых случаях.

### Проверка корректности

Все результаты проверяются сравнением с эталонным результатом `np.dot(A, B)` с допустимой погрешностью 1e-5.

## Оптимизации

1. **Транспонирование матрицы B**: Улучшает кэш-локальность при доступе по столбцам
2. **Распределение работы**: Каждый процесс обрабатывает свой диапазон строк
3. **Минимизация передачи данных**: Передаются только необходимые части матриц

## Ограничения

1. **Память**: Для больших матриц (>50000) требуется значительный объем памяти
2. **Время**: Эксперименты с матрицами >10000 могут занять много времени
3. **Процессы**: Количество процессов ограничено количеством ядер CPU и размером матрицы

